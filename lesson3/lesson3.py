# Деструктирізація

# Як і в інших мовах програмування, в python також можна деструктиризувати об`єкти.
# Тобто витягувати якусь частину із них

# Є у нас кортеж і ми можемо витягувати змінні зразу із його значенням. Це працюватиме і для кортежа і як для списків
# Ми створюємо змінні a і b. В а буде записаний перший елемент, в b буде записаний другий елемент. Це все прирівнюємо до
# нашого кортежу.

# tuple1 = (1,2)
# a,b = tuple1
#
# print(a)
# print(b)

# Вивід буде: 1 2

# Наприклад, у нас є певний список і ми будемо з нього щось витягувати. Прирівнюємо це до списку нашого

# list1 = [1, 2, 3, 4, 5]
# one,two,three = list1
#
# print(one)
# print(two)
# print(three)

# В цьому форматі, ми получимо помилку, оскільки ми не можемо дестриктуризувати наш список. Нам треба
# деструктиризувати все. Щоб це все пропустити, елементи, які починаються з третього і до останього, ми
# ставимо зірочку і нижнє підкреслення *_ . Просто прийнято так робити, що якщо ми щось пропускаємо, робити
# нижнє підкреслювання

# list1 = [1, 2, 3, 4, 5]
# one, two, *_three = list1

# print(one)
# print(two)
# print(_three)

# Вивід буде: 1 2 [3, 4, 5]

# list2 = [1, 2, 3, 4, 5]
# one_1, two_2, *_, three_3 = list2

# print(one_1)
# print(two_2)
# print(three_3)

# Тут вивід буде 1, 2, 5

# list3 = [1, 2, 3, 4, 5, 6]
# _, a_three, *_, z_three = list3
#
# print(a_three)
# print(z_three)
# print(_)

# Вивід буде 2, 6 [3, 4, 5]
# Нижнє підкреслення _ потрібне для того щоб щось пропустити, якщо треба пропустити певну кількість ставимо *_ і все
# решта заміняється змінними

# list4 = [1,2,3,4,5,6]
# alist4, blist4, *_, zlist4, _ = list4
# print(alist4)
# print(blist4)
# print(zlist4)

# Вивід буде: 1, 2, 5
# 1,2 - запишуться в alist4, blist4
# _ буде останнім елементом
# 5 запишеться в zlist4
# *_ ті елементи, які пропускаються 3, 4


# Деструризація об`єктів так само присутня

# Якщо ми маємо словник якись і пробуємо дістати певне значення, воно буде нам сваритись

# dict1 = {
#     "arg1" : 1,
#     "arg2" : 2,
#     "arg3" : 3
# }
#
# k,v = dict1
# print(k)
# print(v)

# Ми можемо деструктиризувати об`єкт у функцію

# dict1 = {
#     "arg1" : 1,
#     "arg2" : 2,
#     "arg3" : 3
# }
#
# def a(arg1 = 'a', arg2 = 'a', arg3 = 'a'):
#     print(arg1, arg2, arg3)
#
#
# a()

# Зараз ми получимо наші значення: a, a, a
# Так само ми можемо, наші ключі повністю співпадають із параметрами функції,
# розпакувати на його складові

# def b(arg1 = 'a', arg2 = 'a', arg3 = 'a'):
#     print(arg1, arg2, arg3)
#
#
# b(**dict1)



# Scope: Область видимості
# В python все зберігається в dictionary
# Це ми можемо побачити в методі global
# Якщо ми створимо змінну, то в об`єкті globals ми її побачимо (попаде в глобальне оточення)

name = 'Max'

def func():
    pass

# print(globals())

# У нашому об`єкті globals буде видно нашу функцію і адрес на неї
# У нас все, замість функцій, зберігається у глобальному виді
# Змінні у функціях трошки працюють по-іншому

# Тобто, у глобальній видимості, нашої змінної nex не буде видно

# def func2():
#     nex = 'next'
# print(globals())

# У нас ще є локальна область видимості


def func3():
    xem = 'mex'
    print(locals())

func3()
print(globals())

# Ми побачимо нашу локальну область видимості: {'xem': 'mex'} Вона відноситься лише до цієї функції і у нас є 1 од`єкт з
# одним ключем

age = '21'

def func4():
    age = '12'
    print(age)
func4()
print(age)

# Вивід буде 12 21
# Ще приклад

# surname = 'surname_1'
#
# def func5():
#     surname = 'surname_3'
#
#     def func6():
#         surname = 'surname_2'
#         print(surname)
#
#     print(surname)
#     func6()
#
#
# func5()
# print(surname)

# Вивід буде: surname_3, surname_2, surname_1
# Але нам потрібно із функції func6 поміняти значення surname в функції func5. Нам треба до неї звернутись

# Нам треба сказати, що ми хочемо працювати із нелокальною змінною

surname = 'surname_1'

def func5():
    surname = 'surname_3'

    def func6():
        nonlocal surname
        surname = 'surname_2'
        print(surname)

    print(surname)
    func6()


func5()
print(surname)

# Ми говоримо: дивись на рівень вище, знайди там surname і переприсвой його.
# nonlocal surname, в цьому моменті ми говоримо, що ми працюємо саме з змінною surname із значенням 'surname_3'